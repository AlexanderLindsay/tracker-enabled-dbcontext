{"name":"Tracker-enabled-dbcontext","tagline":"Tracker-enabled DbContext offers you to implement full auditing in your database","body":"## What is tracker-enabled-dbcontext?\r\ntracker-enabled-dbcontext is a .net library based on entity framework. It is created for tracking the changes in database. This library will records new record additions, record changes & record deletions. When recording record modifications, it will audit previous and new values of the fields. It will also audit the time of change and user who changed/added/deleted the record.\r\n\r\n## What are the types of tracker-enabled-dbcontext?\r\nAt present there are two kinds of tracker-enabled-dbcontext. \r\n\r\n### 1. [TrackerEnabledDbcontext](https://www.nuget.org/packages/TrackerEnabledDbContext)\r\nThis is the main library. It can be used with any type of .net project. For example, \r\n* Console application\r\n* Winforms application\r\n* Web application ( MVC/ Webforms )\r\n* Windows store application\r\n* Class library\r\n\r\n### 2. [TrackerEnabledDbcontext.Identity](https://www.nuget.org/packages/TrackerEnabledDbContext.identity)\r\nThis library was later added to support Asp.Net Identity specifically.\r\n\r\nYou should install any one of them in one project depending upon the type of project type. You will generally not need both of them installed in project, but you can do it if you want.\r\n\r\n## How to install ?\r\n\r\nInstall the desired nuget package using nuget package manager or package manager console.\r\n\r\nYou can install using console, like this- \r\n\r\n```\r\nInstall-Package TrackerEnabledDbContext\r\n```\r\n\r\nOR\r\n\r\n```\r\nInstall-Package TrackerEnabledDbContext.Identity\r\n```\r\n\r\nIf you want to try upcoming beta features, use the following command\r\n\r\n```\r\nInstall-Package TrackerEnabledDbContext -Pre\r\n```\r\n\r\n## How do I use it in my project ?\r\n\r\n**Important Note: This library only works with code first**\r\n\r\nFor TrackerEnabledDbcontext,\r\n\r\n    public class Context : TrackerContext\r\n    {\r\n        public DbSet<Car> Cars { get; set; }\r\n    }\r\n\r\nFor TrackerEnabledDbcontext.Identity,\r\n    \r\n    public class ApplicationDbContext : TrackerIdentityContext<ApplicationUser>\r\n    {\r\n        public ApplicationDbContext(string connectionString)\r\n            : base(connectionString)\r\n        {\r\n        }\r\n\r\n        public DbSet<Blog> Blogs { get; set; }\r\n    }\r\n\r\nPS: Apart from these, many other of constructors are available for both kinds.\r\n\r\n## How to configure tracker to track entities?\r\nIn order to track entities, you will have to specify which entities you want to track. You can further specify which properties to track but it is optional. If you don't specify which properties to track, all properties of that entity will be tracked.\r\n\r\nYou can specify your tracking requirements in 3 ways.\r\n\r\n1. Annotations\r\n2. Fluent API\r\n3. Combination of both\r\n\r\nWith the recent introduction of Fluent API, it gives you more power to change/enable/disable tracking even on runtime.\r\n\r\n### Annotation based configuration\r\n\r\nThe following is an example of Comment class\r\n\r\n    [TrackChanges]\r\n    public class Comment\r\n    {\r\n        public int Id { get; set; }\r\n\r\n        [SkipTracking]\r\n        public string Text { get; set; }\r\n\r\n        public virtual int ParentBlogId { get; set; }\r\n\r\n        public virtual Blog ParentBlog { get; set; }\r\n    }\r\n\r\nBy putting the annotation [TrackChanges], you specify that this entity should be tracked. But if you don't want to track the Text property, just add the annotation [SkipTracking].\r\n\r\nThis entity will have 3 columns in table. Id, Text and ParentBlogId. Although entity framework works even if you don't have the property 'ParentBlogId', this library will require you to have it if you wish to track foreign keys.\r\n\r\n### Fluent API configuration\r\n\r\nIf you don't like to put attributes on your entities, you can use the fluent api to configure tracking as following example.\r\n\r\n            EntityTracker\r\n                .TrackAllProperties<NormalModel>()\r\n                .Except(x => x.Description)\r\n                .And(x => x.Id);\r\n\r\n**Note that if you use both, annotations and fluent api, and they are conflicting for an entity or property, fluent api configuration will be considered high priority**\r\n\r\nLet's consider the following example where you have already configured tracking of a model with either annotations or fluent api. However now on runtime you want to override it for a specific property.\r\n\r\n            EntityTracker\r\n                .OverrideTracking<TrackedModelWithMultipleProperties>()\r\n                .Disable(x => x.StartDate);\r\n\r\nThis way, all configuration is maintained and only StartDate tracking is disabled. You can enable it again using Enable() method.\r\n\r\n## At what levels can tracking be configured ?\r\n\r\nYou can configure tracking at 3 levels.\r\n\r\n1. Global\r\n2. Entity\r\n3. Property\r\n\r\n**Global Level example**\r\n\r\nGlobal level tracking is on by default but you can disable it at runtime as follows:\r\n\r\n    GlobalTrackingConfig.Enabled = false;\r\n\r\n**Entity Level example**\r\n\r\nIts very similar to Property level configuration -\r\n\r\nfor overriding entity level configuration,\r\n\r\n            EntityTracker\r\n                .TrackAllProperties<TrackedModelWithMultipleProperties>()\r\n                .Except(x => x.Name)\r\n                .And(x => x.Description);\r\n\r\n            EntityTracker\r\n                .OverrideTracking<TrackedModelWithMultipleProperties>()\r\n                .Disable();\r\n\r\n            EntityTracker\r\n                .OverrideTracking<TrackedModelWithMultipleProperties>()\r\n                .Enable();\r\n\r\nIn the above example,\r\nyou specified tracking configuration for an entity and its properties. Then override the entity level tracking to be disabled **while maintaining the tracking configuration** and then enabled it again.\r\n\r\n**Note: While working with overrides, if you don't specify property, they work on entity on entity level**\r\n\r\n## How is it tracked ?\r\n\r\n    context.SaveChanges(loggedInUser.Name);\r\nOR\r\n\r\n    context.SaveChangesAsync(loggedInUser.Id);\r\n\r\nAll you have to do is, specify the username or userId while saving changes. However, maintain consistency in this pattern. Don't provide username at some places and userId at other places.\r\n\r\n    context.SaveChanges();\r\n\r\nEven if you don't provide a username or userId, the entity will still be tracked. - Anonymously. This means that tracking data will be stored without a username / userid.\r\n\r\n## Where is my tracked data and how do I see/get it ?\r\n\r\nTracked data is stored in 2 tables\r\n\r\n**1. AuditLog**\r\n\r\nStores entity level tracking information, like when an entity was changed, who changed it, what was the change ( insert /update/ delete ), etc.\r\n\r\n**2. AuditLogDetails**\r\n\r\nStores property level tracking information like, if an entity property was modified what was its old value and what is its new value.\r\n\r\nYou have the freedom to query this tracking data manually as follows\r\n\r\n<img src=\"https://github.com/bilal-fazlani/tracker-enabled-dbcontext/wiki/auditlog.png\" width=\"700\">\r\n\r\n<img src=\"https://github.com/bilal-fazlani/tracker-enabled-dbcontext/wiki/auditlogdetails.png\" width=\"500\">\r\n\r\nYou can also query the tracking data using built-in API as follows-\r\n\r\n            using (Context ctx = new Context())\r\n            {\r\n                IQueryable<AuditLog> allCarLogs = ctx.GetLogs<Car>();\r\n\r\n                Car myCar = ctx.Cars.Single(x => x.Number == \"JH-876G\");\r\n\r\n                IQueryable<AuditLog> myCarLogs = ctx.GetLogs<Car>(myCar.Id);\r\n            }\r\n\r\n\r\n***\r\n\r\nBe creative and figure out how you want to present this data on UI depending upon your project requirement. I have done my own DEMO implementation of UI which you can see in this [sample project.] (https://github.com/bilal-fazlani/tracker-enabled-dbcontext/tree/master/SampleLogMaker) it looks like this. It's pretty much useless implementation - just for demonstration.\r\n\r\n<img src=\"https://github.com/bilal-fazlani/tracker-enabled-dbcontext/wiki/logscreen.png\" width=\"500\">\r\n\r\nWith the data in 2 audit tables, much more can be done. For example, \r\n\r\n1. imagine creating a timeline UI that shows events in the life of an entity.\r\n2. or an API that takes an old datetime and reconstructs entity of that time using this tracking data and returns that entity.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}